# JVM的CPU和内存问题定位思路

## 问题定位技巧

给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里的数据包括：运行日志、异常堆栈、GC日志、线程转储(Tread Stack)、堆栈转储(Heap Dump)等。  

经常使用适当的虚拟机监控和分析的工具，可以加快我们分析数据和定位解决问题的速度，但我们在学习工具前，也应当意识到工具永远都是知识技能的一层包装，没有什么工具是"秘密武器"，学会了就能包医百病。  

### Java的CPU过高定位技巧(此方法可获得问题线程栈)：

1. 获取占用CPU过高的线程ID：top -H -c -p <java_pid>  
2. 获取占用CPU过高的线程栈：jstack -l <java_pid>  
3. 根据线程栈可快速定位问题。  

### Java的堆栈溢出定位技巧(此方法可获得问题类的问题属性)：

1. 获取堆：jmap -dump:live,format=b,file=/some/path/heap_dump.hprof <java_pid>  
2. 使用mat分析堆文件heap_dump.hprof，获得内存泄露的问题类的问题属性。  
3. 走读相关代码，理清问题属性的所有引用，分析可能泄露的原因。注意：堆是一个瞬态的快照，mat只能定位到哪个类的哪个属性(一般这个属性是个集合类)出现了问题，不能确定有问题的线程栈。  

### Java的堆栈溢出定位技巧(此方法可获得问题线程栈，注意此方法要求问题可重现)：

1. 启动jfr，执行一个飞行记录任务：jcmd <java_pid> JFR.start name=memory_leak_detecting settings=profile maxsize=100m maxage=24h  
2. 尝试重现问题。  
3. 获取飞行记录任务数据：jcmd <java_pid> JFR.dump name=memory_leak_detecting filename=/tmp/memory_leak_detecting.jfr compress=true  
4. 获取堆：jmap -dump:live,format=b,file=/some/path/heap_dump.hprof <java_pid>  
5. 使用mat分析堆文件heap_dump.hprof，获得内存泄露的问题类的问题属性。  
6. 使用jmc分析飞行记录任务数据文件memory_leak_detecting.jfr，获得创建问题对象的线程栈。jmc界面导航：飞行记录--内存--分配--新TLAB中的分配、TLAB外部的分配  

## 可能的原因

### 引起CPU过高的可能原因：

1. 线程中有无阻塞的无限循环，出现此类问题比例最高，一般此种情况是代码逻辑有问题导致循环中的sleep代码没有执行到，如实现自定义的flume sink时容易出现此类问题。  
2. 堆栈溢出边缘，频繁Full GC。真实场景：50多个GC线程在跑，每个30%，总共1800%。  
3. 在多线程下使用Hashmap出现死循环，多线程场景下请用ConcurrentHashMap。这个问题遇到过一次，详细分析见：<http://blog.csdn.net/xuefeng0707/article/details/40797085>  
4. 旧版本Java的正则表达式bug，导致对于某些特定的正则表达式出现循环。另外正则表达式效率不高，当业务量达到一定数量级后，正则表达式也会成为性能瓶颈。参见：<http://blog.csdn.net/shixing_11/article/details/5997567>  
5. 对于类似于MQ的生产者和消费者模式中，如果消费者被长期停掉，导致消息在MQ中大量积压，当消费者启动后会长期疯狂的处理消息。此种场景属于业务的正常场景，当然可以考虑消息过期策略，保证MQ中的存活消息不会太多。  
6. JNI中有死循环代码。  
7. JDK自身存在死循环BUG。  

### 引起堆栈溢出的可能原因：

1. 类的静态的集合类型的变量长期持有大量无用对象。如果此变量作为缓存，可以考虑使用WeakHashMap，在内存不足时，释放近期未访问的缓存。  
2. 一次加载大量数据到内存中，可能导致内存溢出。很多业务系统可能存在类似问题，在将某些数据展示到前台页面的时候，由于过滤条件无法有效过滤数据，数据撑爆了堆，导致业务系统瞬间堆栈溢出。  

### 引起系统挂死的可能原因：

系统挂死，从表面上来看，是系统不处理响应。对于Web系统来说，http请求无页面返回；对于消息系统来说，系统无响应消息；总而言之，系统像死了一样。  

导致系统挂死的原因很多，不同的系统有不同的可能，具体的问题需要在具体的场景下进行分析，但根本原因有如下几种。  

1. 线程死锁。  
2. 线程永远得不到唤醒(wait/notify/sleep)。  
3. 资源不足导致线程挂死在获取资源的代码中(如获取数据库连接)。  
4. 无限死循环。  
5. 内存溢出。  
6. 关键线程异常退出，导致消息得不到处理。  
7. 远程调用，对方一直没有返回。一般表现是长期处于读socket状态。  

## 性能优化的时机

通常一个系统在完成功能测试之后，紧接着就会做性能测试，当发现系统的性能远远不能满足设计要求时，性能优化就显得至关重要了；性能优化的先决条件是系统在真正需要优化的时候再做，不要盲目的做优化，否则优化的结果可能就是得不偿失。  

当确认系统需要优化的时候，首要任务就是识别系统的性能瓶颈，通常一个系统的性能瓶颈点会集中在一处或者数出，只要搞定了关键瓶颈点，系统性能一般都会大幅提升。  

当前的性能瓶颈永远只有一处，只有解决了当前这一处性能瓶颈，你才知道下一个性能瓶颈在哪里。性能瓶颈是动态的，低负载时不是瓶颈的地方，在高负载时却可能成为瓶颈，性能优化是一个持续的过程。  

## 其他

### 土法调优两大件

1. Heap Dump  
2. Thread Dump  

### 你真正要的Java Mission Control

如果你使用过JProfiler，Yourkit，VisualVM还有Eclipse的Profiler插件等一堆Profiler工具，或者用JavaSimion等在代码里打印过metrics，最后会发现免费的JMC才是你想要的。  

代替收费的JProfiler的好东西，以前Bea JRockit的宝贝，现在随着JDK7 up40以后的版本免费自带了，不过只在开发环境免费，就是说理论上不能拿它来连生产环境的机器。  

另一个让人开心的事情就是JMC采用采样，而不是传统的代码植入的技术，对应用性能的影响非常非常小，完全可以开着JMC来做压测(唯一影响可能是full gc多了，减少一些监控项看看)。不会像以前，开了代码植入型的Profiler，出来的性能测试结果差了一个数量级不说，热点完全可能是错误的，这是一个真实的故事，具体细节就不说了。  
