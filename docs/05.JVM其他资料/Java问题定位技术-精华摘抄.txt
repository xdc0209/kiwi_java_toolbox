§3.5.4 Java 完全垃圾回收
    完全垃圾回收(FULL GC)，是指虚拟机进行一次彻底的垃圾回收。由于完全垃圾回收计算
量非常大，是高耗CPU的操作，当堆内存设置很大时，由于垃圾对象非常多，每次对象扫描用
的时间非常可观，常常需要几秒钟的时间才能完成。在极端的情况下，甚至需要几十秒。如果
采用串行垃圾回收，那么这个系统在完全垃圾回收期间，java代码时不运行的。在实时场合，
这个时间会造成很严重的问题。因此在系统内存设置很大的场合，采用并行/并发垃圾回收会
有更佳的效果。


§4 关于并发和多线程
    是否应该使用多线程在很大程度上取决于手头的应用程序的类型。如果应用程序是计算
密集型(如纯数学运算)的，并受CPU 功能的制约，则只有多CPU(或者多个内核)机器能够
从更多的线程中受益，单CPU下，多线程不会带来任何性能上的提升，反而有可能由于线程切
换等额外开销而导致性能下降。当应用程序必须等待缓慢的资源(如网络连接或数据库连接
上的数据)时，多线程会让系统的CPU充分利用起来，当一个线程被阻塞时，另一个线程可以
继续利用CPU。总之，使用多线程不会增加CPU 的处理能力。但在某些场景下可以更加充分
地利用CPU。


§4.5 进程线程多，是否就意味着我的程序可以获得更多的CPU？
    只有当CPU成为整个系统的瓶颈，那么这句话就是成立的，也就是说，如果CPU一直在高
位运行，那么线程多的进程，被执行到的几率就更高一些。在CPU不忙的时候，每个程序都能
够得到及时的服务，该问题也就不存在。


§4.6 线程的数量一般设为多少比较合理？
    我们知道，多线程在大多数场合可以提高整个系统的性能或者吞吐量，但一个系统中到底
多少个线程才是合理的？总的来说，线程数量过大过少都不好。过大导致线程切换开销过大，
反而导致整个系统性能下降。过小导致CPU不能充分被利用，性能仍然上不去。系统到底使用
多少线程，依据系统线程运行是否充分利用了CPU.如果每个线程都100%的使用CPU的话，那
么系统一个线程就够了，但实际情况是，在如下情况下是不消耗CPU的：
    • 磁盘IO
    • 网络IO
    • 带有3D加速卡的图形运算
    • 等待输入
    特别是磁盘IO,网络IO相比CPU的速度，是非常慢的，也就是说，在这很长的时间CPU是
空闲的，此时系统如果有多个线程那么其它线程可以在该线程空闲的时候利用CPU,从而提
高CPU的利用率，系统总的吞吐量也就上去了。当实际的应用系统中，如果只有一个线程的
话，该线程有访问远程数据库的行为，那么在等待数据返回的期间，这期间是不消耗CPU的。

    总得来说，一段代码导致CPU空闲的比例越大(空闲的CPU周期/总的CPU周期)，那么线
程的数量就应该加大，当一个线程被阻塞时，其它线程可以继续执行业务代码，这样可以充
分利用CPU。不能简单得说线程多性能就好，或者说线程少性能就好。在一种应用下到底需
要多少线程，不是取决于线程数量本身，而是取决于你的具体应用类型。如果执行线程不消
耗CPU的时间片越大，那么线程数量大对性能就好。当然，一个系统只通过调整线程的数量，
不一定能带来性能的真正提高，比如，设计/编码不合理导致系统中存在资源争用(比如长期
锁等待)，此时只靠调整线程的数量，可能根本不会有任何效果，在这种情况下,随着压力的加
大，CPU的使用率并不能一直上升并趋近于饱和(即100%),往往只能达到某一个中间值，随后
随着压力的增大，系统的失败率开始上升。因此一个设计良好的系统，需要考虑各种因素，才
能将性能调到最大。


§4.7 关于线程池
    如果系统有可能在某个时刻任务过多，那么使用线程池要特别小心，因为这些任务可能
将线程池中的所有线程耗光，同时将任务队列塞满，从而造成任务提交失败，因此将一个任务
提交给线程池的时候，已经要对提交是否成功进行检查，如果提交不成功，就需要进行日志纪
录，以方便定位问题，否则这种问题非常难以定位。


§4.9 线程的阻塞
    为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程
对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准
备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访
问控制问题，Java 引入了对阻塞机制的支持。


§5.1 异常退出幽灵代码
                                              比如，我们知道，对于一些资源(系统资
源或者自定义资源)，使用与关闭需要成对出现，如果由于异常退出导致关闭资源的代码没有
被执行到，那么则会造成资源泄漏。资源泄漏多了，就会导致整个系统无法工作。再具体一点，
比如打开一个文件，由于异常退出导致关闭文件代码没有被执行，则会造成文件句柄泄漏。打
开一个socket，不需要的时候没有close也会造成文件句柄泄漏，打开一个数据库连接，使用完
后没有关闭，就会造成连接泄漏，等等。(其实GC也会帮忙关闭流，不过自己的事情自己做。)

    从上面的介绍看，避免这个幽灵代码，修改的方法有两种，其中之一是将关键代码放
在catch(Throwable t)异常处理代码中，确保任何异常情况下，关键代码仍然可以被执行，那为什
么在关键场合需要catch(Throwable),而不是catch(Exception)呢? 在一般情况，catch(Exception)基
本上能够捕捉到绝大多数异常，但是在苛刻的运行环境下，仍然有漏网之鱼，这在某些应用下，
一次遗漏也会导致致命的问题。Throwable比Exception更为低级一些，可以保证所有的异常都
能被捕获，从而使得在任何情况下,"善后"代码都能得到执行。

                                                            因此在关键的代码处，捕
获Throwable相比捕获Exception更加安全可靠。


§5.1.1 异常退出幽灵代码导致的资源泄漏
    对于上面提到的资源，当使用完成后，一定要显式调用关闭资源的代码。一旦遗漏，势必
造成资源的耗尽，最终导致系统无法工作。
    有的程序员认为，在对象离开作用域之后，Java启动垃圾回收，而垃圾回收会自动将资源
释放掉，这种说法实际上是不成立的。Java的自动垃圾回收只能保证内存被回收，不能保证资
源被回收，二者是不同的概念。不同的资源回收有不同的方法，总而言之，必须显式地调用资
源的回收代码，资源才能被真正地回收。


§6.1 不稳定的Runtime.getRuntime().exec()
    getInputStream()用来获取进程的输出流，注意这里的InputStream是从Java的角度来看,而
不是从外部程序的角度来看。外部程序的输出即是Java程序的输入。同样地，外部程序的输入
流，从java角度来看，确是一个输出流。


§6.3.2 线程池
    由于一个进程内的线程不是无限的资源。操作系统对每一个进程都有一个最大线程数量
的限制。为了避免系统在高峰期达到了最大线程数量而导致的应用失败，引入了线程池的设
计。通过引入线程池，系统获得了如下好处：
    • 将系统最大线程的数量给控制住，避免因线程数量超过系统限制而导致的系统不稳定。
    • 避免了频繁去new Thread这种耗时操作，因此对系统的性能有一定的价值。
    一般系统的最大线程数限制在几百到几千个，依赖于不同的系统而不同。


§7.5 正确的视角看虚拟机
    虚拟机实际上就是一个程序，当程序启动时，就开始执行保存在.class文件中的字节码指
令。.class中的指令的执行是由虚拟机程序来执行的。更直观地说，.class相当于是脚本，java.exe是
脚本执行程序。就像perl脚本执行程序，perl是可执行程序，perl脚本是脚本语言，perl可执行
程序根据perl脚本指令运行。perl脚本与class文件的差别在于，perl脚本是可读的，而class文件
是二进制不可读的。但二者的地位是一样的。理解了.class和虚拟机的关系, 我们就会知道在执
行.class文件的时候究竟发生了什么事情，这样更有助于我们理解一些内在行为, class是JVM的
运行脚本。


§10.3.2 其它设计关键点
    接收/发送消息使用消息分发机制，及任务队列的机制。
        1. 接收消息队列的消息分发线程，只负责将原始消息分发到另外的消息处理线程，一
        定不要进行耗时的parse操作。
        2. 对于有优先级区别的消息要分别使用不同的队列，避免使用同一个队列。如心跳消
        息的优先级要高，最好使用一个独立的队列，以避免在高峰时段，普通消息队列满而
        导致心跳这种高优先级的消息得不到及时处理，而影响稳定性。即对于有高优先级
        的消息，需要使用独立的队列进行处理，而不能和普通消息共用队列的方式，否则容
        易导致系统不稳定，甚至整个系统僵死。在消息系统的设计中，首先要检查整个系统
        的消息是否是对等的？如果有的消息优先级高，则应该为高优先级的消息使用专用
        的队列，以避免被普通消息耗尽队列导致整个系统僵死。

    另外，消息队列要注意控制长度，因为消息系统中普遍有超时，当一个消息的响应在指定
    的时间内没有返回的话，那么对方一般会重发，当重发超过一定的次数，仍然没有返回的
    话，将停止再发。在这种机制下，我们要注意消息队列的长度。新来的消息排在后面待
    处理，如果消息队列的长度过长，那么该消息要等待很长的时间才能被处理到，如果等待
    的时间超过了超时重发的总值，此时即使再处理该消息对方也不再理会。这样导致整个
    系统就死掉了，因为排在后面的每一个消息都会遇到这个情况。

    进行消息分发的消息处理线程，要确保永不退出。


§12.1 在高端机器上，一个JVM好还是多个JVM好？
    总的来说，如果系统线程设计比较合理，能充分利用CPU，那么单个进程的性能不会比多
个进程性能低，并且单个进程占用更少的系统资源。如果线程模型设计不合理，无法充分利
用CPU,那么多个进程总的处理能力可能会更高。如果使用了32位的JDK ,但运行在64位的操
作系统上，而恰好内存是系统的受限瓶颈，此时启动多个进程可以利用更多的内存，从而总的
性能可能会更高。


§12.2 关于Java进程监控-watchdog
    watchdog又叫看门狗。负责监控程序是否正常运行。watchdog是系统在网上运行的最后一
根救命稻草。


§12.2.1 如何检测系统异常
    真正的系统异常要根据不同的场景来设计。最佳的设计是驱动真正的业务，这样可以真
正的检测出系统是否异常。只有设计一个仿真的检测机制，才是最可靠的检测方法。


§12.4 关于负载控制-动态过负荷还是静态过负荷?
    自适应的判断方法，来动态获得系统的能力数据，即动态过负荷
        – CPU的使用情况，如CPU的使用率达到80%,认为系统压力达到了最大的允许压力。
        – 消息队列的长度，如消息队列中消息堆积达到80%,就认为系统压力达到了最大的允
          许压力。
        – 线程池线程的使用情况，如空闲线程少于20%，就认为系统忙了。

    但实际情况确不是这样的。自适应依赖于一些外部参数判断系统当前的压力，在嵌入式
硬件可能比较适用，因为在这种系统下，系统一般是独占的(应用程序自己独占)，而操作系
统任务调度往往也是比较单纯的，CPU的空闲基本反映了系统的忙闲。但在工作站或者服务
器上，由于机器上运行的程序往往有多个，另外，系统可能也存在定时任务，会不定期启动，
因此CPU使用率过高可能是其它外部程序导致的。另外，由于多线程设计不当，或者参数配
置不当(如线程数量配置过小)，往往CPU还没达到80%,系统已经无法正常工作。除非自己写
的程序可以随着压力的加大可以达到100%的使用率，但这实际上是很难的。同样的，消息队
列的长度仍然不能反映系统当前的空闲状态，除非瓶颈在消息队列上，消息队列的处理能力
才能反映系统的能力。因为消息分发线程处理能力一般很快，会很快将消息产生一个任务，并
扔给线程池，但最终线程中也有队列，实际上可能是在线程池中产生任务堆积而不是在消息
队列中堆积。更为严重的是，如果消息队列中出现堆积，说明系统压力已经远远超过了自身的
能力。线程池中有任务堆积亦然，正常情况线程池和消息队列中都不能产生堆积，一旦产生堆
积，说明系统压力已经超过了系统的极限，此时检测出来，已经晚矣，因此根据消息队列和线
程池队列都无法进行系统压力的判断。最为可靠的办法还是人为设定一个阈值，这个是非常
安全可靠。虽然缺乏自适应能力，但在可靠性高的场合，可靠比方便更为重要。


§12.5 机器设多个IP的原理？
    关于计算机网络方面的知识领域非常广，但作为程序开发人员理解到如下的层面就能很
好得理解其它东西了。
    • 在网卡的层面，所有局域网内部都是广播的(与TCP/IP的广播不同，这里的广播实际上是
      电路级的广播，即最底层的向一个导线施加一个电压，那么Hub会同时施加到所有连接的
      网线上)，即当前局域网的所有机器都可以收到数据包，这也就是为什么在局域网的任何
      一个机器上都可以抓到整个网络上的包的原因。
    • TCP/IP协议会忽略所有的不属于本机IP的包。因此，从外面看起来是点对点。
    • 当一个机器有多个IP的时候，TCP/IP层会把所有属于本机IP的包都收下来，并通知应用
      层。这个就是多个IP的本质。


§12.6.2 什么是好的日志？
    满足了如下条件就是好的日志：
    1. 打印的是最原始的错误信息，没有经过任何转换
    2. 给出了正确的日志级别，以保证在出错情况下，关心的日志能够真得打印出来
    3. 在异常发生时，日志中有明确的调用上下文。


§12.9 String的值为什么不能改变？
    我们都知道String里面的内容不能修改，但很多时候我们下意识的认为这是java对这个类
做了什么特殊处理。其实不然，String类是一个普通类，虚拟机并没有对这个类进行区别对待，
只所以有这个限制，是因为String类没有提供修改内容的接口。如String + String 返回一个
新的String,而不是修改原来的String. 其它方法也是这个道理，没有提供修改内容的方法，因
此String里面的内容永远不会被改变。


§12.13 如何实现JVM Shutdown钩子函数？
    钩子函数不应该执行任何耗时的操作，而且应该是线程安全的，不应该依赖于其它任
    何服务，因为整个系统都在关闭自己的过程中，不能将自己的命运寄托于其它可能状
    态已经不正常的服务上。


§13.6 Web系统吊死（挂死）的定位思路
    (c) 系统存在死循环等。一个线程遭遇死循环，往往会有如下两种连锁反应：
        • 由于该死循环的线程占有一把锁，而且永不释放，从而导致其它所有请求该锁
          的线程挂起，请求得不到继续处理，造成整个系统挂死。
        • 在单CPU的机器上，该死循环的线程可能耗尽CPU,导致其它线程的处理非常慢，
          直到有大量超时发生，从外面看，整个程序挂死。


§13.12 关于线程死亡/线程跑飞
    在server端的应用程序，系统往往会有一些全生命周期的线程，这些线程一旦运行，则永
不退出，如处理消息队列的线程，线程池中的线程等。这些线程在系统中往往处于最关键的位
置，一旦这些线程异常退出，常常造成的是整个系统的瘫痪。因此这种问题严重影响系统的稳
定性和可靠性，同时这种问题具有很深的隐蔽性，一般只有在大压力或者极端的情况下，问题
才会暴露，这样就带来了很大的隐患。

    • 关键任务提交给线程池，没有对提交结果结果进行检查并处理，如果交给线程池不成功，
      那么该关键任务得不到执行，从而导致系统无法工作。线程池有如下几个原因，可能任务
      提交失败：
          – 系统繁忙，导致线程池任务队列满，从而将新提交的任务抛弃。此时提交任务代码需
            要做容错处理，等待重新提交，以确保该关键任务得到执行。


§13.13 关于虚拟机Core Dump
    解决的办法是升级到当前最新的子版本。如你当前1.5.0_06版本，那么请尽快升级到1.5.0_15(直
到当前最新的)，注意只升级到"_"所表示的子版本。这个子版本升级基本上只解决了bug,虚
拟机特性没有很大的变化，可以大胆地升级。但是如果进行大版本的升级，就需要重新进
行全面的测试才可以。如从1.4升级到1.5，从1.5升级到1.6等，这种大版本可能升级会遇到
各种各样的兼容问题，需要进行专门的测试。但是子版本升级基本上不用考虑升级带来
的兼容性问题。


§13.23 系统性能过低
    从多次打印堆栈看，正在"干活"的线程（即执行用户代码的线程）始终是3到4个，其它线
程都处于在线程池中空闲状态。同时发现该进程占用的CPU非常高，几乎接近于饱和。说明
很有可能这几个线程消耗了大量的CPU。该环境有4个CPU, 除非是CPU密集型操作，每个线
程长期占有一个CPU的计算量。因此元凶基本锁定在这四个线程正在实行的代码上。从堆栈
来看，这三四个线程执行的代码都是解析soap消息，因此怀疑soap消息的解析上导致了CPU过
高，从而导致系统整体性能低。
    至此，下一步的目标就是查找到底是什么原因导致了soap解析计算量大？是解析算法太复
杂？还是soap消息太大？首先经过抓包分析，发现一个soap消息大约是0.5M, 按照这个消息量
计算，百兆网络上只能传递大约25个消息(0.5*25=12.5M)。而解析这个消息消耗大量的CPU,系
统慢也就是情理之中了。至此问题得到了定位。


附录B.5 Fatal Error Log
    当致命错误发生时，虚拟机会创建相应的错误日志，该文件格式在不同的发布里可能稍
有不同。该日志中如含如下内容：
    • 发生致命错误的位置。
    • 致命错误的描述。
    • 文件头。
    • 线程信息。
    • 进程信息。
    • 系统信息。


附录B.5.4 Thread Section Format
VM State(虚拟机状态)再下一部分信息是虚拟机状态，指明整个虚拟机的状态，状态分为如下几种类
型：

一般的VM状态                           描述
not at a safepoint (normal execution)  正常执行.
at safepoint                           所有的线程被阻塞在VM中，等待一个特定的VM操作完成.
synchronizing                          需要一个特定的VM操作，该VM正在等待所有阻塞的线程.
